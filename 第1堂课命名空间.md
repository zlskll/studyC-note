写博客

C++primer，effctiveC++

：： 域作用限定域

左边是空，就表示在全局域中访问

<img src="https://raw.githubusercontent.com/zlskll/picture/main/test/202503161055540.png" alt="image-20240904205709394" style="zoom:50%;" />

默认是局部域，如果不加::域作用限定域的话，就是局部域。

所以一般现在局部域中搜索，然后再去全局域中搜索，如果局部域中有就不去全局域里找了。

一般不会在命名空间里搜索，除非展开，展开就相当于暴露到全局了，表示编译时是否去命名空间中搜索，和包含头文件不一样，头文件是预处理的时候，把头文件的内容拷贝过来，两者不一样。

展开为 using namespace 命名空间;  (是在全局域里展开)

命名空间定义的时候，

  namespace 名字{      可以定义变量，函数，类型，并允许嵌套           }   //末尾没有分号

所以C++开头是这个意思，只有展开了命名空间，或者直接指定，才会去这个命名空间中搜索。

指定的意思是， std::cout<<1;  这个是指定。

小知识点，头文件里可以放命名空间的定义，引用头文件时候，如果引用了多个头文件，引用后同名命名空间就合并了，内容合并到一块了。					

建议项目里面不要去展开，因为直接展开会有风险，如果定义跟库重名，就报错了，很不方便。项目里面建议用指定访问，不要轻易展开命名空间。

还有个小技巧，不能全部展开，可以部分展开， 

using std::cout;

using std::endl;

这个是部分展开，把一些常用的展开就行了。

C++这个命名空间机制，解决的是C语言命名冲突的缺陷。

查文档可以上 cplusplus  cpprefence

printf  scanf比 cout  cin快，因为cout是C++里面的，C++要兼容C，所以C++里cout的时候会检查C的缓冲区里面有没有东西，会进行同步，这就会耗费一点时间。有一种办法叫关闭cout的同步，可以上网搜一下。





